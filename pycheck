#!/usr/bin/env python
"""A helper script to run static analysis tools on Python code and
report issues.

Currently supported tools are Pyflakes and PEP8.

## Usage from Emacs

Add something like the following to your init file:

```lisp
(add-hook 'python-mode-hook
          (lambda ()
            (flymake-mode)
            )
          )

(defun flymake-pycheckers-init ()
    (let* ((temp-file (flymake-init-create-temp-buffer-copy
                       'flymake-create-temp-inplace))
           (local-file (file-relative-name
                        temp-file
                        (file-name-directory buffer-file-name))))
      (list (expand-file-name "~/bin/pycheck") (list local-file))))

(add-to-list 'flymake-allowed-file-name-masks
               '("\\.py\\'" flymake-pycheckers-init))
```

Replace `~/bin/pycheck` with the location where you've saved this
script.

The results will be printed to standard out in a format compatible
with flymake.

## Usage from the command line

Simply run this script with a Python file as the only argument.

## Caveats

You may also need to set up your path up in the __main__ function at
the bottom of the file and change the #! line above to an appropriate
interpreter.

## Copyright

Copyright (c) 2013 Kevin Birch <kmb@pobox.com>. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal with the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimers.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimers in the
  documentation and/or other materials provided with the distribution.

* Neither the names of the copyright holders, nor the names of the
  authors, nor the names of other contributors may be used to endorse
  or promote products derived from this Software without specific
  prior written permission.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.

## Colophon

This script is adapted from code orignally written by Jason Kirtland
<jek@discorporate.us>[1] and released under the Creative Commons Share
Alike 1.0 license[2].

Jason's code was based on original work taken from the PythonMode
page[3] of the Emacs Wiki, author unknown.

[1] https://bitbucket.org/jek/sandbox/src/tip/pycheckers
[2] http://creativecommons.org/licenses/sa/1.0/
[3] http://www.emacswiki.org/emacs/PythonMode

"""

## Customization ##

# Checkers to run be default, when no --checkers options are supplied.
# One or more of pep8 or pyflakes, separated by commas
default_checkers = 'pep8, pyflakes'

# A list of error codes to ignore.
# default_ignore_codes = ['E225', 'W114']
default_ignore_codes = []

## End of customization ##

import os
from os import path
import re
import sys

from subprocess import Popen, PIPE
from pyflakes.api import checkPath
from pep8 import StyleGuide, BaseReport

try:
    u = unicode
except NameError:
    u = str


class LintRunner(object):
    """Base class provides common functionality to run python code checkers.

    """

    output_format = ("%(level)s %(error_type)s%(error_number)s:"
                     "%(description)s at %(filename)s line %(line_number)s.")

    output_template = dict.fromkeys(
        ('level', 'error_type', 'error_number', 'description',
         'filename', 'line_number'), '')

    output_matcher = None

    sane_default_ignore_codes = set([])

    command = None

    run_flags = ()

    def __init__(self, ignore_codes=(), use_sane_defaults=True):
        self.ignore_codes = set(ignore_codes)
        if use_sane_defaults:
            self.ignore_codes ^= self.sane_default_ignore_codes

    def fixup_data(self, line, data):
        return data

    def process_output(self, line):
        m = self.output_matcher.match(line)
        if m:
            return m.groupdict()

    def run(self, filename):
        args = [self.command]
        args.extend(self.run_flags)
        args.append(filename)

        process = Popen(args, stdout=PIPE, stderr=PIPE)

        for line in process.stdout:
            match = self.process_output(line)
            if match:
                tokens = dict(self.output_template)
                tokens.update(self.fixup_data(line, match))
                print self.output_format % tokens

        for line in process.stderr:
            match = self.process_output(line)
            if match:
                tokens = dict(self.output_template)
                tokens.update(self.fixup_data(line, match))
                print self.output_format % tokens


class OutputFormatter(object):
    """Base class for output formatters of tool output
    """

    ErrorLevel = 'ERROR'
    WarningLevel = 'WARNING'
    InfoLevel = 'INFO'

    def __init__(self, output_stream=sys.stdout):
        self.output_stream = output_stream

    def error(self, filename, message):
        pass

    def event(self, filename, description, line_number, event_level, event_kind, event_number):
        pass


class FlymakeFormatter(OutputFormatter):
    """Format tool output for flymake

    """

    error_output = u('{filename}: {message}.\n')
    event_output = u('{level} {kind}{number}: {message}'
                     ' at {filename} line {line}.\n')

    def error(self, filename, message):
        self.output_stream.write(self.error_output.format(filename=filename, message=message))

    def event(self, filename, description, line_number, event_level=OutputFormatter.ErrorLevel, event_kind='', event_number=''):
        self.output_stream.write(self.event_output.format(level=event_level,
                                                          kind=event_kind,
                                                          number=event_number,
                                                          message=description,
                                                          filename=filename,
                                                          line=line_number))


class PyflakesReporter(object):
    """Report events from the pyflakes tool.

    """

    def __init__(self, formatter):
        """
        Construct a PyflakesReporter.

        Args:
            formatter: an instance of OutputFormatter
        """
        self.formatter = formatter

    def unexpectedError(self, filename, msg):
        """
        An unexpected error occurred trying to process filename.

        Args:
            filename: the filename causing an error
            msg: the message to report
        """
        self.formatter.error(filename, msg)

    def syntaxError(self, filename, msg, lineno, offset, text):
        """
        There was a syntax errror in filename.

        """
        event_level = self._guess_event_level(msg)
        self.formatter.event(filename, msg, lineno, event_level, 'PY', 'S')

    def flake(self, event):
        """
        pyflakes found something wrong with the code.

        Args:
            event: A pyflakes.messages.Message.
        """
        event_level = self._guess_event_level(event.message)
        msg = event.message % event.message_args
        self.formatter.event(event.filename, msg, event.lineno,
                             event_level, 'PY', 'F')

    def _guess_event_level(self, message):
        if 'imported but unused' in message:
            return OutputFormatter.WarningLevel
        elif 'redefinition of unused' in message:
            return OutputFormatter.WarningLevel
        else:
            return OutputFormatter.ErrorLevel


class PyflakesRunner(LintRunner):
    """Run the pyflakes tool.

    """

    def run(self, filename):
        checkPath(filename, PyflakesReporter(FlymakeFormatter()))


class Pep8Reporter(BaseReport):
    """Report events from the pep8 tool.

    """

    def error(self, line_number, offset, text, check):
        """Report an error, according to options."""
        code = super(Pep8Reporter, self).error(line_number, offset,
                                               text, check)

        event_level = OutputFormatter.WarningLevel if code.startswith('W') else OutputFormatter.ErrorLevel
        self.formatter.event(self.filename, text[5:], line_number, event_level, code[:1], code[1:])
        return code


class Pep8Runner(LintRunner):
    """Run the pep8 tool.

    """
    def run(self, filename):
        style_guide = StyleGuide(config_file=True)
        reporter = style_guide.init_report(reporter=Pep8Reporter)
        reporter.formatter = FlymakeFormatter()
        style_guide.input_file(filename)


def croak(*msgs):
    for m in msgs:
        sys.stderr.write(m.strip())
        sys.stderr.write('\n')
    sys.stderr.flush()
    sys.exit(1)

RUNNERS = {
    'pyflakes': PyflakesRunner,
    'pep8': Pep8Runner,
}

if __name__ == '__main__':
    # transparently add a virtualenv to the path when launched with a venv'd
    # python.
    os.environ['PATH'] = path.dirname(sys.executable) + ':' + os.environ['PATH']

    if len(sys.argv) < 2:
        croak("Usage: %s [file]" % sys.argv[0])
    elif len(sys.argv) > 2:
        from optparse import OptionParser
        parser = OptionParser()
        parser.add_option("-i", "--ignore_codes", dest="ignore_codes",
                          default=[], action='append',
                          help="error codes to ignore")
        parser.add_option("-c", "--checkers", dest="checkers",
                          default='pep8,pyflakes',
                          help="comma separated list of checkers")
        options, args = parser.parse_args()
        if not args:
            croak("Usage: %s [file]" % sys.argv[0])

        checkers = options.checkers or default_checkers
        ignore_codes = options.ignore_codes or default_ignore_codes
        source_file = args[0]
    else:
        source_file = sys.argv[1]
        checkers = default_checkers
        ignore_codes = default_ignore_codes

    for checker in checkers.split(','):
        try:
            cls = RUNNERS[checker.strip()]
        except KeyError:
            croak(("Unknown checker `%s'" % checker),
                  ("Expected one of %s" % ', '.join(RUNNERS.keys())))
        runner = cls(ignore_codes=ignore_codes)
        runner.run(source_file)

    sys.exit(0)
